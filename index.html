<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048</title>
    <style>
        html{
    background-color: #dbb898;
    font-family: Arial, Helvetica, sans-serif;
}
#set{
    
    position: absolute;
    top: 20px;
    height:200px ;
    width: 99%;
}

#button{
    position: absolute;
    background-color:#776e65;
    border-radius: 5px;
    border: solid black 5px;
    width: 100px;
    height:50px;
    left: 30px;
}

.s{
    display: inline-block;
}
#title{
    text-align: center; 
    margin-top: 50px;
    font-size: 40px;
}
#titlebox{
    height: 150px;
    width: 150px;
    margin: 10px; 
    background-color: rgb(249,231,0) ;
    z-index: 3;
    border-radius:5px
    
}
#timebox{
    font-size:30px; 
    position: absolute;
    top: 40px;
}
#scorebox{
    font-size: 30px; 
    position: relative;
    top: 15px;
}
#bestscorebox{
    font-size: 30px; 
    position: absolute;
    top: 125px;
    left:175px;
}




#game{
    width: 400px;
    height: 400px;
    margin: 30px auto ;
}

#gamebox{
    position:absolute;
    width: 99%;
    top: 240px;
    height: 500px;
}

#gridbox{
    display: flex;
    position: absolute;
    z-index: 1;
    width: 460px;
    height: 460px;
    background-color: #bbada0;
  	border-radius: 10px;  
    justify-content: space-evenly;
    align-content: space-evenly;
    flex-wrap: wrap;
}


.grid{
    z-index: 2;
    width:100px;
    height:100px;
    background-color: rgba(238,228,218,.35);
    border-radius: 4px;
    
}
.tile{
    position: absolute;
    z-index: 4;
    width: 100px;
    height:100px;
    border-radius: 4px;
    display: inline-block;
    transition: 100ms ease-in-out;
    transition-property: transform;
}

.tile-text{
    text-align: center;
    font-size: 55px;
    font-weight: 700;
    color: #776e65;
    line-height:100px;
}

.move{
    position: absolute;
    height:50px;
    width:50px;
    display:flex;
    border-radius: 5px;
    border: solid black 3px;
}

#up{
    top: 790px;
    left:50%;
}
#down{
    top: 860px;
    left:50%;
}
#left{
    top: 825px;
    left:40%;
}

#right{
    top: 825px;
    left:60%;
}
.tile-1-1 {
    transform: translate(12px, 12px);
}

.tile-1-2 {
    transform: translate(124px, 12px);
}

.tile-1-3 {
    transform: translate(236px, 12px);
}

.tile-1-4 {
    transform: translate(348px, 12px);
}

.tile-2-1 {
    transform: translate(12px, 124px);
}

.tile-2-2 {
    transform: translate(124px, 124px);
}

.tile-2-3 {
    transform: translate(236px, 124px);
}

.tile-2-4 {
    transform: translate(348px, 124px);
}

.tile-3-1 {
    transform: translate(12px, 236px);
}

.tile-3-2 {
    transform: translate(124px, 236px);
}

.tile-3-3 {
    transform: translate(236px, 236px);
}

.tile-3-4 {
    transform: translate(348px, 236px);
}

.tile-4-1 {
    transform: translate(12px, 348px);
}

.tile-4-2 {
    transform: translate(124px, 348px);
}

.tile-4-3 {
    transform: translate(236px, 348px);
}

.tile-4-4 {
    transform: translate(348px, 348px);
}

.tile.tile-2 .tile-text {
    background: #eee4da;
}

.tile.tile-4 .tile-text {
    background: #ede0c8;
}

.tile.tile-8 .tile-text {
    color: #f9f6f2;
    background: #f2b179
}

.tile.tile-16 .tile-text {
    color: #f9f6f2;
    background: #f59563
}

.tile.tile-32 .tile-text {
    color: #f9f6f2;
    background: #f67c5f
}

.tile.tile-64 .tile-text {
    color: #f9f6f2;
    background: #f65e3b
}

.tile.tile-128 .tile-text {
    color: #f9f6f2;
    background: #edcf72;
    box-shadow: 0 0 30px 10px rgba(243,215,116,.2381),inset 0 0 0 1px rgba(255,255,255,.14286);
    font-size: 45px
}

.tile.tile-256 .tile-text {
    color: #f9f6f2;
    background: #edcc61;
    box-shadow: 0 0 30px 10px rgba(243,215,116,.31746),inset 0 0 0 1px rgba(255,255,255,.19048);
    font-size: 45px
}

.tile.tile-512 .tile-text {
    color: #f9f6f2;
    background: #edc850;
    box-shadow: 0 0 30px 10px rgba(243,215,116,.39683),inset 0 0 0 1px rgba(255,255,255,.2381);
    font-size: 45px
}

.tile.tile-1024 .tile-text {
    color: #f9f6f2;
    background: #edc53f;
    box-shadow: 0 0 30px 10px rgba(243,215,116,.47619),inset 0 0 0 1px rgba(255,255,255,.28571);
    font-size: 35px
}

.tile.tile-2048 .tile-text {
    color: #f9f6f2;
    background: #edc22e;
    box-shadow: 0 0 30px 10px rgba(243,215,116,.55556),inset 0 0 0 1px rgba(255,255,255,.33333);
    font-size: 35px
}

.tile.tile-super .tile-text {
    color: #f9f6f2;
    background: #3c3a32;
    font-size: 30px
}

@keyframes pop {
    0% {
        scale: 0;
    }
    50% {
        scale: 1.2;
    }
    100% {
        scale: 1;
    }
}
	
@keyframes appear {
    0% {
        opacity: 0;
        scale: 0;
    }
    100% {
        opacity: 1;
        scale: 1;
    }
}
.tile-new .tile-inner {
    animation: appear 200ms ease 0ms;
}
.tile-merged .tile-inner{
    animation: pop 200ms ease 0ms;
    animation-fill-mode: backwards;
}
    </style>
</head>
<body>
    <div id="wholegame">
        <div id="set" class="s">

            <div id="titlebox" class="s">
                <h2 id="title">2048</h2>
            </div>

            <div id="timebox" class="s">
                <b>time:</b>
                <b id="timer">0</b>
            </div>

            <div id="scorebox" class="s">
                <b>score:</b>
                <b id="score">0</b>
            </div>
            <div id="bestscorebox" class="s">
                <b>best score:</b>
                <b id="bestscore">0</b>
            </div>
            <div>
                <button type="button" onclick="newGame()" id="button">
                    <b style="font-size: 30px;">重置</b>
                </button>
                <button type="button" style="position:relative;" onclick="swich()"><b>切換</b></button>
            </div>

        </div>



        <div id="gamebox">
            <div id="game">
                <div id="gridbox"></div>
                <div id="tilebox"></div>
            </div>
        </div>


        <div>
            <button id="left" class="move" type="button" onclick="left()"><b>左</b></button>
            <button id="right" class="move" type="button" onclick="right()"><b>右</b></button>
            <button id="up" class="move" type="button" onclick="up()"><b>上</b></button>
            <button id="down" class="move" type="button" onclick="down()"><b>下</b></button>
        </div>
    </div>
    <script>
        
var score= document.getElementById('score')
var bestscore=document.getElementById('bestscore')
var best=0
bestscore.textContent=best
var newscore=0
score.textContent=newscore
var timer = document.getElementById('timer')
var n=1

function swich(){
    var oldcss=document.getElementById('onpage')
    var newcss=document.createElement('link')
    newcss.rel='stylesheet'
    newcss.href=oldcss.href.includes('/成發/2048.css')
    ? '/成發/2048.css'
    : '/成發/homo.css'

    newcss.onload=()=>{if (oldcss) oldcss.remove()}
    document.head.appendChild(newcss)
}


var flow =setInterval(()=>{
    timer.textContent = +timer.textContent+1
},1000)

for(let i=1;i<=16;i++){
    let blok = document.createElement("div")
    blok.classList.add('grid')
    document.getElementById("gridbox").appendChild(blok)
}



const size=4
var tilebox= document.getElementById('tilebox')
var grids=Array(size).fill(0).map(()=>Array(size).fill(0))

function addNew(n){
    let blank=[]
    for(let i=0;i<size;i++){
        for(let j=0;j<size;j++){
            if(grids[i][j]==0) blank.push([i,j])
        }
    }

    for(let i=0;i<n;i++){
        let rn =Math.floor(Math.random() * blank.length)
        let newsize= 0
        if(Math.random()<0.6) newsize=2 //隨機取2或4
        else newsize=4
        let tile = document.createElement('div')
        let text = document.createElement('div')
        text.textContent = newsize
        text.classList.add('tile-text')
        tile.appendChild(text)
        tile.classList.add('tile', `tile-${blank[rn][0] + 1}-${blank[rn][1] + 1}`, `tile-${newsize}`, 'tile-new');
        tilebox.appendChild(tile)
        grids[blank[rn][0]][blank[rn][1]] = newsize;
        blank.splice(rn,1)
    }
}

addNew(2)

function update(n){
    let gridArr= document.getElementsByClassName('tile')
    while(gridArr.length) gridArr[0].remove() //清空方塊

    for(let i=0;i<size;i++){
        for(let j=0;j<size;j++){
            if(grids[i][j]){
                let tile= document.createElement('div')
                tile.classList.add('tile',`tile-${i+1}-${j+1}`)
                if(grids[i][j]<=2048) tile.classList.add(`tile-${grids[i][j]}`)
                else tile.classList.add('tile-super')
                tilebox.appendChild(tile)

                let text= document.createElement("div")
                text.classList.add('tile-text')
                text.textContent= `${grids[i][j]}`
                tile.appendChild(text)
            }
        }
    }
    score.textContent=newscore
    if(best<=newscore){
        best=newscore;
        bestscore.textContent=best;
    }
    
    addNew(n)  //新增方塊
}

function move(Xs, Ys) {
    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
            if (Xs[i][j] || Ys[i][j]) {
                let grid = document.getElementsByClassName(`tile-${i + 1}-${j + 1}`);
                grid = grid[grid.length - 1]; // 取得最後一個元素(最新)
                grid.classList.add(`tile-${i + Ys[i][j] + 1}-${j + Xs[i][j] + 1}`);
                grid.classList.remove(`tile-${i + 1}-${j + 1}`);
            }
        }
    }
}

function delay(n) {
    return new Promise(function(r){
        setTimeout(r, n*100);
    });
}

async function left(){
    let copy= grids.map( e => e.map( f => f))//複製
    let merged = {
        x: [],
        y: []
    };
    let notZeros = Array(4).fill(0).map(() => Array(0)); // 創建陣列放不是0的位置
    let moveTos = Array(4).fill(0).map(() => Array(0)); // 創建陣列放要移動到的位置
    let trans = { // 創建物件放X位移陣列和Y位移陣列
        x: Array(size).fill(0).map(() => Array(size).fill(0)),
        y: Array(size).fill(0).map(() => Array(size).fill(0))
    }
    // 找非0位置
    copy.forEach((row, i) => row.forEach((item, j) => {if (item != 0) notZeros[i].push(j)}));

    copy.forEach((ele, index, arr)=>arr[index]=arr[index].filter(e => e!=0 )) //過濾0

    for (let i = 0; i < size; i++) {
        if (copy[i].length == 1) moveTos[i].push(0);
        for (let j = 0; j < copy[i].length - 1; j++) {
            if (copy[i][j] == copy[i][j+1]) {
                copy[i][j] *= 2;
                newscore+= copy[i][j]
                copy[i].splice(j+1, 1);
                moveTos[i].push(j, j);
                if (j + 2 >= copy[i].length) moveTos[i].push(j+1);
                merged.x.push(j + 1);
                merged.y.push(i + 1);
            } else if (j == copy[i].length - 2) moveTos[i].push(j, j + 1);
            else moveTos[i].push(j);
        }
    }

    for (let i = 0; i < size; i++) {
        for(let j = 0; j < notZeros[i].length; j++) {
            trans.x[i][notZeros[i][j]] = +moveTos[i][j] - +notZeros[i][j];
        }
    }

    for(let i=0;i<size;i++){
        while(copy[i].length<4) copy[i].push(0)           //補0
    }
    let same=0
    for(let i=0;i<size;i++){
        for(let j=0;j<size;j++){
            if(copy[i][j]==grids[i][j]){       //檢查有無變動
                same++
            }
        }
    }
    if(same==16) return 0 //沒變
    move(trans.x, trans.y)
    await delay(1)
    grids = copy.map(e=>e) //變了

    update(1)
}

async function right(){
    let copy= grids.map( e => e.map( f => f)) //複製
    let merged = {
        x: [],
        y: []
    };
    copy= copy.map(e=>e.reverse())  //左右鏡像

    let notZeros = Array(4).fill(0).map(() => Array(0)); // 創建陣列放不是0的位置
    let moveTos = Array(4).fill(0).map(() => Array(0)); // 創建陣列放要移動到的位置
    let trans = { // 創建物件放X位移陣列和Y位移陣列
        x: Array(size).fill(0).map(() => Array(size).fill(0)),
        y: Array(size).fill(0).map(() => Array(size).fill(0))
    }
    // 找非0位置
    copy.forEach((row, i) => row.forEach((item, j) => {if (item != 0) notZeros[i].push(size - 1 - j)}));

    copy.forEach((ele, index, arr)=>arr[index]=arr[index].filter(e => e!=0 )) //過濾0
    

    for (let i = 0; i < size; i++) {
        if (copy[i].length == 1) moveTos[i].push(0);
        for (let j = 0; j < copy[i].length - 1; j++) {
            if (copy[i][j] == copy[i][j+1]) {
                copy[i][j] *= 2;
                copy[i].splice(j+1, 1);
                moveTos[i].push(j, j);
                if (j + 2 >= copy[i].length) moveTos[i].push(j+1);
                merged.x.push(4 - j);
                merged.y.push(i + 1);
            } else if (j == copy[i].length - 2) moveTos[i].push(j, j + 1);
            else moveTos[i].push(j);
        }
    }

    // change value
    for (let i = 0; i < size; i++) {
        for (let j = 0; j < moveTos[i].length; j++) {
            moveTos[i][j] = size - 1 - +moveTos[i][j];
        }
    }

    for (let i = 0; i < size; i++) {
        for(let j = 0; j < notZeros[i].length; j++) {
            trans.x[i][notZeros[i][j]] = +moveTos[i][j] - +notZeros[i][j];
        }
    }
    

    for(let i=0;i<size;i++){
        while(copy[i].length<4) copy[i].push(0)           //補0
    }
    copy=copy.map(e=>e.reverse()) //記得轉回來

    let same=0
    for(let i=0;i<size;i++){
        for(let j=0;j<size;j++){
            if(copy[i][j]==grids[i][j]){       //檢查有無變動
                same++
            }
        }
    }
    if(same==16) return 0 //沒變
    move(trans.x, trans.y)
    await delay(1)
    grids = copy.map(e=>e) //變了

    update(1, merged.x, merged.y);
}

async function up(){

    let copy= grids[0].map((_,index)=> grids.map(e=>e[index])) //複製+轉置(行列互換)
    let merged = {
        x: [],
        y: []
    };

    let notZeros = Array(4).fill(0).map(() => Array(0)); // 創建陣列放不是0的位置
    let moveTos = Array(4).fill(0).map(() => Array(0)); // 創建陣列放要移動到的位置
    let trans = { // 創建物件放X位移陣列和Y位移陣列
        x: Array(size).fill(0).map(() => Array(size).fill(0)),
        y: Array(size).fill(0).map(() => Array(size).fill(0))
    }
    // 找非0位置
    copy.forEach((row, i) => row.forEach((item, j) => {if (item != 0) notZeros[i].push(j)}));

    copy.forEach((ele, index, arr)=>arr[index]=arr[index].filter(e => e!=0 )) //過濾0

    for (let i = 0; i < size; i++) {
        if (copy[i].length == 1) moveTos[i].push(0);
        for (let j = 0; j < copy[i].length - 1; j++) {
            if (copy[i][j] == copy[i][j+1]) {
                copy[i][j] *= 2;
                newscore+= copy[i][j]
                copy[i].splice(j+1, 1);              //合併
                moveTos[i].push(j, j);
                if (j + 2 >= copy[i].length) moveTos[i].push(j+1);
                merged.x.push(j + 1);
                merged.y.push(i + 1);
            } else if (j == copy[i].length - 2) moveTos[i].push(j, j + 1);
            else moveTos[i].push(j);
        }
    }

    for(let i=0;i<size;i++){
        while(copy[i].length<4) copy[i].push(0)           //補0
    }

    copy= copy[0].map((_,index)=> copy.map(e=>e[index])) //轉置回來

    let same=0
    for(let i=0;i<size;i++){
        for(let j=0;j<size;j++){
            if(copy[i][j]==grids[i][j]){       //檢查有無變動
                same++
            }
        }
    }

    for (let i = 0; i < size; i++) {
        for(let j = 0; j < notZeros[i].length; j++) {
            trans.y[notZeros[i][j]][i] = +moveTos[i][j] - +notZeros[i][j];
        }
    }

    if(same==16) return 0 //沒變
    move(trans.x, trans.y)
    await delay(1)
    grids = copy.map(e=>e) //變了

    update(1)
}

async function down(){
    let copy= grids[0].map((_,index)=> grids.map(e=>e[index])) //複製+轉置(行列互換)
    let merged = {
        x: [],
        y: []
    };
    copy= copy.map(e=>e.reverse())

    let notZeros = Array(4).fill(0).map(() => Array(0)); // 創建陣列放不是0的位置
    let moveTos = Array(4).fill(0).map(() => Array(0)); // 創建陣列放要移動到的位置
    let trans = { // 創建物件放X位移陣列和Y位移陣列
        x: Array(size).fill(0).map(() => Array(size).fill(0)),
        y: Array(size).fill(0).map(() => Array(size).fill(0))
    }
    // 找非0位置
    copy.forEach((row, i) => row.forEach((item, j) => {if (item != 0) notZeros[i].push(size - 1 - j)}));

    copy.forEach((ele, index, arr)=>arr[index]=arr[index].filter(e => e!=0 )) //過濾0

    for (let i = 0; i < size; i++) {
        if (copy[i].length == 1) moveTos[i].push(0);
        for (let j = 0; j < copy[i].length - 1; j++) {
            if (copy[i][j] == copy[i][j+1]) {
                copy[i][j] *= 2;
                newscore+= copy[i][j]
                copy[i].splice(j+1, 1);              //合併
                moveTos[i].push(j, j);
                if (j + 2 >= copy[i].length) moveTos[i].push(j+1);
                merged.x.push(j + 1);
                merged.y.push(i + 1);
            } else if (j == copy[i].length - 2) moveTos[i].push(j, j + 1);
            else moveTos[i].push(j);
        }
    }

    for (let i = 0; i < size; i++) {
        for (let j = 0; j < moveTos[i].length; j++) {
            moveTos[i][j] = size - 1 - +moveTos[i][j];
        }
    }

    //設置移動動畫
    for (let i = 0; i < size; i++) {
        for(let j = 0; j < notZeros[i].length; j++) {
            trans.y[notZeros[i][j]][i] = +moveTos[i][j] - +notZeros[i][j];
        }
    }

    for(let i=0;i<size;i++){
        while(copy[i].length<4) copy[i].push(0)           //補0
    }
    copy= copy.map(e=>e.reverse())
    copy= copy[0].map((_,index)=> copy.map(e=>e[index])) //轉置回來

    let same=0
    for(let i=0;i<size;i++){
        for(let j=0;j<size;j++){
            if(copy[i][j]==grids[i][j]){       //檢查有無變動
                same++
            }
        }
    }

    for (let i = 0; i < size; i++) {
        for(let j = 0; j < notZeros[i].length; j++) {
            trans.y[notZeros[i][j]][i] = +moveTos[i][j] - +notZeros[i][j];
        }
    }

    if(same==16) return 0 //沒變
    move(trans.x, trans.y)
    await delay(1)
    grids = copy.map(e=>e) //變了
    update(1, merged.x, merged.y);
}
function newGame() {
    newscore=0
    grids = Array(size).fill(0).map(() => Array(size).fill(0));
    update(2);
    timer.textContent=0;

}

document.body.addEventListener('keyup', Keydetect )

function Keydetect(e){
    console.log(e.code)
    switch (e.code){
        case "KeyA":
            left()
            break           
        case "KeyD":
            right()
            break
        case 'KeyW':
            up()
            break
        case 'KeyS':
            down()
            break
        case 'KeyR':
            newGame()
            break
    }

}



    </script>
</body>
</html> 